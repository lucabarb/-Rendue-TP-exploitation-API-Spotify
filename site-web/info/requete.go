package info

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

var token string

func Token() {
	urlToken := "https://accounts.spotify.com/api/token"
	const clientId = "73de89b9e33546c9b61a545458d113b6"
	const clientSecret = "d19a24917a694ff3b1f64edfd7ee4a13"

	httpClient := http.Client{
		Timeout: time.Second * 10,
	}
	BodyReq := bytes.NewBufferString("grant_type=client_credentials&client_id=" + clientId + "&client_secret=" + clientSecret)
	req, errReq := http.NewRequest("POST", urlToken, BodyReq)
	if errReq != nil {
		fmt.Println("Error creating request :", errReq.Error())
		os.Exit(1)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, errRes := httpClient.Do(req)
	if resp.Body != nil {
		defer resp.Body.Close()
	} else {
		fmt.Println("Error creating response :", errRes.Error())
		os.Exit(2)
	}
	var reponseMap map[string]interface{}

	decoder := json.NewDecoder(resp.Body)
	errJSON := decoder.Decode(&reponseMap)
	if errJSON != nil {
		fmt.Println("Error reading JSON :", errJSON.Error)
		os.Exit(4)
	}

	token = reponseMap["access_token"].(string)
}

func JUL(data ApiDataJul) ApiDataJul {

	apiURL := "https://api.spotify.com/v1/artists/3IW7ScrzXmPvZhB27hmfgy/albums"

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		fmt.Println("Erreur lors de la création de la requête:", err)
		return data
	}
	req.Header.Set("Authorization", "Bearer "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Erreur lors de l'envoi de la requête:", err)
		return data
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Erreur lors de la lecture de la réponse:", err)
		return data
	}
	json.Unmarshal(body, &data)
	return data
}

func SDM(data ApiDataSdm) ApiDataSdm {
	apiURL := "https://api.spotify.com/v1/tracks/0EzNyXyU7gHzj2TN8qYThj?market=FR"

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		fmt.Println("Erreur lors de la création de la requête:", err)
		return data
	}
	req.Header.Set("Authorization", "Bearer "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Erreur lors de l'envoi de la requête:", err)
		return data
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Erreur lors de la lecture de la réponse:", err)
		return data
	}
	json.Unmarshal(body, &data)
	return data
}
